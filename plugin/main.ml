open Extraction_plugin
open File_utils

(** Effect handler for [Print]. *)
let ocaml_handle_print (str : Pstring.t) : unit =
  Log.printf "%s" (Pstring.to_string str)

(** [with_warning warn f] executes [f ()] with Rocq warning [warn] enabled.
    It resets the warnings afterwards. *)
let with_warning (warn : string) (f : unit -> 'a) : 'a =
  let warnings = CWarnings.get_flags () in
  (* Strangely, the function [CWarnings.with_warn] does this differently.
     I believe this version is correct. *)
  let new_warnings = (if warnings = "" then "" else warnings ^ ",") ^ warn in
  CWarnings.set_flags new_warnings;
  let res = f () in
  CWarnings.set_flags warnings;
  res

(** Recursively extract a constant. Returns the name of the created .ml file. *)
let extract ~opaque_access ~dir (ref : Libnames.qualid) : string =
  let ml_file = dir </> "extracted.ml" in
  let mli_file = dir </> "extracted.mli" in
  (* Extract the reference, producing a .mli file and a .ml file.
     We set a warning to ensure the extracted code doesn't access opaque
     definitions (i.e. proofs).
     [Flags.silently] removes the debug messages printed by extraction. *)
  with_warning "-extraction-opaque-accessed" @@ fun () ->
    Flags.silently (Extract_env.full_extraction ~opaque_access (Some ml_file)) [ ref ];
  (* Remove the .mli file. *)
  Sys.remove mli_file;
  ml_file

(** Compile the code generated by [extract] as a shared library (.cmxs extension).
    Build logs and errors are recorded in files [build.log] and [build.err].
    Returns the name of the created shared library file. *)
let compile ~dir ~ml_file : string =
  let cmxs_file = Filename.chop_extension ml_file ^ ".cmxs" in
  let cmd =
    Printf.sprintf "cd %s && ocamlfind ocamlopt -package extraction-experiments.plugin -thread -shared -runtime-variant _pic -o %s %s > build.log 2> build.err"
      dir cmxs_file ml_file
  in
  let code = Sys.command cmd in
  if code <> 0 then
    Log.error "Plugin error: failed to compile OCaml file %s.\nRead %s and %s for more information."
      ml_file (dir </> "build.log") (dir </> "build.err")
  else cmxs_file

(** Dynamically link the shared library we compiled. *)
let link ~cmxs_file : unit =
  try Dynlink.loadfile_private cmxs_file with
  | _ -> Log.error "Plugin error: failed to dynamically link OCaml shared library %s" cmxs_file

(** Extract, compile, and link the constant [ref]. *)
let main ~opaque_access (ref : Libnames.qualid) : unit =
  let dir = mk_tmp_dir "metaprog" in
  let ml_file = extract ~opaque_access ~dir ref in
  let cmxs_file = compile ~dir ~ml_file in
  link ~cmxs_file
