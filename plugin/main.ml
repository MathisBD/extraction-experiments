open Extraction_plugin
open File_utils

(** [with_warning warn f] executes [f ()] with Rocq warning [warn] enabled.
    It resets the warnings afterwards. *)
let with_warning (warn : string) (f : unit -> 'a) : 'a =
  let warnings = CWarnings.get_flags () in
  (* Strangely, the function [CWarnings.with_warn] does this differently.
     I believe this version is correct. *)
  let new_warnings = (if warnings = "" then "" else warnings ^ ",") ^ warn in
  CWarnings.set_flags new_warnings;
  let res = f () in
  CWarnings.set_flags warnings;
  res

(** Recursively extract a constant. Returns the name of the created .ml file. *)
let extract ~opaque_access ~dir (ref : Libnames.qualid) : string =
  let ml_file = dir </> "extracted.ml" in
  let mli_file = dir </> "extracted.mli" in
  (* Extract the reference, producing a .mli file and a .ml file.
     We set a warning to ensure the extracted code doesn't access opaque
     definitions (i.e. proofs).
     [Flags.silently] removes the debug messages printed by extraction. *)
  with_warning "-extraction-opaque-accessed" @@ fun () ->
    Flags.silently (Extract_env.full_extraction ~opaque_access (Some ml_file)) [ ref ];
  (* Remove the .mli file. *)
  Sys.remove mli_file;
  ml_file

(** Compile the code generated by [extract] as a shared library (.cmxs extension).
    Returns the name of the created shared library file. *)
let compile ~dir ~ml_file : string =
  let cmxs_file = Filename.chop_extension ml_file ^ ".cmxs" in
  let _cd_cmd = Filename.quote_command "cd" [ dir ] in
  let compile_cmd =
    Filename.quote_command
      ~stdout:(dir </> "build.log")
      ~stderr:(dir </> "build.err")
      "ocamlfind"
      [ "ocamlopt"
      ; "-package" ; "extraction-experiments.plugin"
      ; "-tread"
      ; "-shared"
      ; "-runtime-variant"; "_pic"
      ; "-o"; cmxs_file
      ; ml_file ]
  in
  let ret_code =
    Sys.command (Printf.sprintf "bash -c \"( . '/home/mathis/.opam/opam-init/init.sh' > /dev/null 2> /dev/null) && (eval $(opam env)) && %s\"" compile_cmd)
  in
  if ret_code <> 0 then
    (* Read the error log. *)
    let error_log =
      try read_file (dir </> "build.err") with _ -> "EMPTY ERROR LOG"
    in
    Log.error "Plugin error: failed to compile OCaml file %s. Error log:\n%s"
      ml_file error_log
  else cmxs_file

(** Dynamically link the shared library we compiled. *)
let link ~cmxs_file : unit =
  try Dynlink.loadfile_private cmxs_file with
  | _ -> Log.error "Plugin error: failed to dynamically link OCaml shared library %s" cmxs_file

(** Extract, compile, and link the constant [ref]. *)
let main ~opaque_access (ref : Libnames.qualid) : unit =
  let dir = mk_tmp_dir "metaprog" in
  let ml_file = extract ~opaque_access ~dir ref in
  let cmxs_file = compile ~dir ~ml_file in
  link ~cmxs_file
