open Extraction_plugin
open File_utils

(** [with_warning warn f] executes [f ()] with Rocq warning [warn] enabled.
    It resets the warnings afterwards. *)
let with_warning (warn : string) (f : unit -> 'a) : 'a =
  let warnings = CWarnings.get_flags () in
  (* Strangely, the function [CWarnings.with_warn] does this differently.
     I believe this version is correct. *)
  let new_warnings = (if warnings = "" then "" else warnings ^ ",") ^ warn in
  CWarnings.set_flags new_warnings;
  let res = f () in
  CWarnings.set_flags warnings;
  res

(** Recursively extract a constant. Returns the name of the created .ml file. *)
let extract ~opaque_access ~dir (ref : Libnames.qualid) : string =
  let ml_file = dir </> "extracted.ml" in
  let mli_file = dir </> "extracted.mli" in
  (* Extract the reference, producing a .mli file and a .ml file.
     We set a warning to ensure the extracted code doesn't access opaque
     definitions (i.e. proofs).
     [Flags.silently] removes the debug messages printed by extraction. *)
  with_warning "-extraction-opaque-accessed" @@ fun () ->
    Flags.silently (Extract_env.full_extraction ~opaque_access (Some ml_file)) [ ref ];
  (* Remove the .mli file. *)
  Sys.remove mli_file;
  ml_file

(** Compile the code generated by [extract] as a shared library (.cmxs extension).
    Returns the name of the created shared library file. *)
let compile ~dir ~ml_file : string =
  let cmxs_file = Filename.chop_extension ml_file ^ ".cmxs" in
  let compile_cmd =
    Filename.quote_command
      ~stdout:(dir </> "build.log")
      ~stderr:(dir </> "build.err")
      "ocamlfind"
      [ "ocamlopt"
      ; "-package" ; "extraction-experiments.plugin"
      ; "-thread"
      ; "-shared"
      ; "-runtime-variant"; "_pic"
      ; "-o"; cmxs_file
      ; ml_file ]
  in
  let cmd = Printf.sprintf "cd %s && eval $(opam env) && %s" (Sys.getcwd ()) compile_cmd in
  if Sys.command cmd <> 0 then
    (* Read the error log. *)
    let error_log =
      try read_file (dir </> "build.err") with _ -> "EMPTY ERROR LOG"
    in
    Log.error "Plugin error: failed to compile OCaml file %s. Error log:\n%s"
      ml_file error_log
  else cmxs_file

(** [is_exn_allowed e] returns [true] if exception [e] is allowed to be raised
    when executing the extracted code. *)
let is_exn_allowed (e : exn) : bool =
  match e with
  | CErrors.UserError _ -> true
  | _ -> false

(** Dynamically link the shared library we compiled. *)
let link ~cmxs_file : unit =
  try Dynlink.loadfile_private cmxs_file with
  (* We allow the linked program to raise some specific errors. *)
  | Dynlink.Error (Library's_module_initializers_failed e) when is_exn_allowed e ->
    raise e
  (* Any other error is unexpected.
     As indicated in the documentation of CErrors we don't catch critical errors. *)
  | e when CErrors.noncritical e ->
    let err_msg = Printexc.to_string e in
    let err_trace = Printexc.get_backtrace () in
    Log.error "Plugin error: dynamic linking error:\n%s%s" err_msg err_trace

(** Extract, compile, and link the constant [ref]. *)
let main ~opaque_access (ref : Libnames.qualid) : unit =
  let dir = mk_tmp_dir "metaprog" in
  let ml_file = extract ~opaque_access ~dir ref in
  let cmxs_file = compile ~dir ~ml_file in
  link ~cmxs_file
